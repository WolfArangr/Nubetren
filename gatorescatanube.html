<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gato en el Laberinto ‚òÅÔ∏è</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: 'Press Start 2P', cursive;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 10px;
      box-sizing: border-box;
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 1.2rem;
    }
    canvas {
      background: #222;
      display: block;
      width: 90vw;
      max-width: 672px;
      height: auto;
      border-radius: 8px;
    }
    #level {
      margin-top: 5px;
      font-size: 1rem;
      user-select: none;
    }
    #controls {
      margin-top: 15px;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 10px;
      width: 200px;
      max-width: 90vw;
      user-select: none;
    }
    .btn {
      background: #333;
      border: 2px solid #fff;
      border-radius: 8px;
      color: #fff;
      font-size: 1.8rem;
      text-align: center;
      line-height: 1;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      aspect-ratio: 1 / 1;
      transition: background 0.2s;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    .btn:active {
      background: #555;
    }
    @media (max-width: 350px) {
      #controls {
        width: 150px;
        gap: 6px;
      }
      .btn {
        font-size: 1.3rem;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
</head>
<body>
  <h1>üê± Gato al Rescate de la Nube ‚òÅÔ∏è</h1>
  <canvas id="gameCanvas"></canvas>
  <div id="level">Nivel: <span id="levelCount">1</span></div>
  <div id="controls">
    <div></div>
    <div class="btn" data-dir="up">‚¨ÜÔ∏è</div>
    <div></div>
    <div class="btn" data-dir="left">‚¨ÖÔ∏è</div>
    <div class="btn" data-dir="down">‚¨áÔ∏è</div>
    <div class="btn" data-dir="right">‚û°Ô∏è</div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const baseTileSize = 32;
    const tilesX = 21;
    const tilesY = 21;

    let tileSize;
    let maze, player, goal, startTime, timerId;
    const steps = { count: 0 };
    let level = 1;

    function resizeCanvas() {
      const displayWidth = canvas.clientWidth;
      const scale = displayWidth / (baseTileSize * tilesX);
      tileSize = baseTileSize * scale;

      canvas.width = tileSize * tilesX;
      canvas.height = tileSize * tilesY;
    }

    function generateMaze() {
      const maze = Array.from({ length: tilesY }, () => Array(tilesX).fill(1));
      function carve(x, y) {
        const dirs = [
          [0, -2],
          [2, 0],
          [0, 2],
          [-2, 0]
        ].sort(() => Math.random() - 0.5);

        maze[y][x] = 0;

        for (let [dx, dy] of dirs) {
          const nx = x + dx,
            ny = y + dy;
          if (
            ny > 0 &&
            ny < tilesY - 1 &&
            nx > 0 &&
            nx < tilesX - 1 &&
            maze[ny][nx] === 1
          ) {
            maze[y + dy / 2][x + dx / 2] = 0;
            carve(nx, ny);
          }
        }
      }
      carve(1, 1);
      for (let x = 0; x < tilesX; x++) {
        maze[0][x] = 1;
        maze[tilesY - 1][x] = 1;
      }
      for (let y = 0; y < tilesY; y++) {
        maze[y][0] = 1;
        maze[y][tilesX - 1] = 1;
      }
      return maze;
    }

    function findEmptyTile(avoidX = null, avoidY = null, minDistance = 0) {
      let x, y;
      do {
        x = Math.floor(Math.random() * (tilesX - 2)) + 1;
        y = Math.floor(Math.random() * (tilesY - 2)) + 1;
      } while (
        maze[y][x] !== 0 ||
        (avoidX !== null &&
          avoidY !== null &&
          Math.abs(x - avoidX) + Math.abs(y - avoidY) < minDistance)
      );
      return { x, y };
    }

    function resetGame() {
      resizeCanvas();
      maze = generateMaze();
      player = findEmptyTile();
      goal = findEmptyTile(player.x, player.y, 16);
      steps.count = 0;
      startTime = Date.now();
      clearInterval(timerId);
      timerId = setInterval(draw, 100);
      draw();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < tilesY; y++) {
        for (let x = 0; x < tilesX; x++) {
          if (maze[y][x] === 1) {
            ctx.fillStyle = '#444';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
          }
        }
      }
      ctx.font = `${tileSize * 0.8}px serif`;
      ctx.fillText('‚òÅÔ∏è', goal.x * tileSize + tileSize * 0.12, goal.y * tileSize + tileSize * 0.8);
      ctx.fillText('üê±', player.x * tileSize + tileSize * 0.12, player.y * tileSize + tileSize * 0.8);

      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      ctx.fillStyle = 'white';
      ctx.font = `${tileSize * 0.35}px sans-serif`;
      ctx.fillText(`‚è±Ô∏è ${elapsed}s`, 10, tileSize * 0.4);
      ctx.fillText(`üë£ ${steps.count}`, 10, tileSize * 0.75);
    }

    function move(dir) {
      const dx = { left: -1, right: 1, up: 0, down: 0 }[dir];
      const dy = { left: 0, right: 0, up: -1, down: 1 }[dir];
      const nx = player.x + dx;
      const ny = player.y + dy;

      if (maze[ny] && maze[ny][nx] === 0) {
        player.x = nx;
        player.y = ny;
        steps.count++;
        draw();
        if (player.x === goal.x && player.y === goal.y) {
          const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
          const totalSteps = steps.count;
          setTimeout(() => {
            level++;
            document.getElementById('levelCount').textContent = level;
            alert(`¬°Has encontrado la nube! ‚òÅÔ∏èüò∫\nTiempo: ${totalTime}s\nPasos: ${totalSteps}\n¬°Nivel ${level}!`);
            resetGame();
          }, 100);
        }
      }
    }

    // --- NUEVO: Movimiento continuo ---
    let moveInterval = null;

    function startMoving(dir) {
      if (moveInterval) return; // ya se est√° moviendo

      move(dir); // mover inmediatamente para respuesta r√°pida
      moveInterval = setInterval(() => {
        move(dir);
      }, 330);
    }

    function stopMoving() {
      if (moveInterval) {
        clearInterval(moveInterval);
        moveInterval = null;
      }
    }

    // Asignar eventos a botones para movimiento continuo
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(btn => {
      const dir = btn.dataset.dir;

      // Para mouse
      btn.addEventListener('mousedown', () => startMoving(dir));
      btn.addEventListener('mouseup', stopMoving);
      btn.addEventListener('mouseleave', stopMoving);

      // Para toque t√°ctil
      btn.addEventListener('touchstart', e => {
        e.preventDefault(); // evitar que el touch genere clic u otros efectos
        startMoving(dir);
      }, { passive: false });
      btn.addEventListener('touchend', e => {
        e.preventDefault();
        stopMoving();
      });
      btn.addEventListener('touchcancel', stopMoving);
    });

    // Ajustar canvas si la ventana cambia de tama√±o
    window.addEventListener('resize', () => {
      resetGame();
    });

    resetGame();
  </script>
</body>
</html>
